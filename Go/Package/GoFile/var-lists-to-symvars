#!/usr/bin/env bash

## Go/Package/GoFile.var-lists-to-symvars
## Read all @var:* list files, create symvar for each variable declaration

## @var: files must contain valid golang global variable declarations
## General syntax:
##      var NAME TYPE = VALUE   -- fully
##      var NAME = VALUE        -- type is inferred from value
##      var NAME TYPE           -- var set $o the type's 0-value
## NAME can also be a list:
##      var N1, N2, N3 TYPE = VALUE
##      var N1, N2, N3 = VALUE
##      var N1, N2, N3 TYPE
## Declarations can be also be in a var (...) block, and will be
## missing the 'var' keyword on each line.

parse_values() {
    local -i num=$1
    local value="$2"
    local -i p=0
    local -i v=0
    local c
    (( num == 1 )) && values[0]="$value" && return
    while (( p < ${#value} )); do
        c=${value:$p:1}
        p+=1
        [[ $c == ',' && -z $INQUOTE ]] && v+=1 && continue
        values[$v]+=$c
        [[ $c != '"' ]] && continue
        if [[ -n $INQUOTE ]]; then INQUOTE= ; else INQUOTE=1; fi
    done
}

parse_declaration() {
    ## Expecting declarations of the form:
    ##      var name type
    ##      var name1, name2, name3 type
    ##      var name type = value
    ##      var name = value
    ##      var name1, name2, name3 type = v1, v2, v3
    ##      var name1, name2, name3 = v1, v2, v3
    local declaration="$1" && shift
    local -a dw=( $declaration )
    local -i i j
    local name
    ## empty names[] array is declared in caller
    local type
    local value
    local -a values

    i=0
    ## var must be the first word in the declaration.
    [[ ${dw[i++]} == var ]] || return

    ## Declaration may have one name or several names separated by commas.
    while (( i < ${#dw[@]} )); do 
        name=${dw[i++]}
        [[ $name == *, ]] && {
            names+=(${name%,})
            continue
        }
        names+=($name)
        break
    done

    ## Next must be the variable type or '=' and value.

    type=${dw[i++]}
    if [[ $type == '=' || ${dw[$i]} == '=' ]]; then
        [[ $type == '=' ]] && type=
        ## Go will infer the variable type from the value if no type is given.
        parse_values ${#names[@]} "${declaration#*=}"
        [[ ${#values[@]} == ${#names[@]} ]] || {
            warn "number of values (${#values[@]}) must match names (${#names[@]})"
            return
        }
    fi

    ## Now we have names, type, and values, so should be all set.
    for ((j=0; j<${#names[@]}; j++)); do 
        name="${names[j]}"
        value="${values[j]}"
        if [[ -n $value ]]; then
            ## We have the name and value, may have the type or not.
            if [[ -n $type ]]; then
                svname=var:$type:$name
                svvalue="var $name $type =$value"
            else
                svname=var:$name
                svvalue="var $name =$value"
            fi
        else
            ## We have only the name, no value, so must have the type.
            svname=var:$type:$name
            svvalue="var $name $type"
        fi
        ## Now we have the symvar name and value, ready to save.

        ## check if symvar already exists:
        if [[ -h $svname ]]; then
            if [[ -n $FORCE ]]; then
                symvar -f "$svname" "$svvalue"
            else 
                warn "symvar file exists: $svname =$svvalue"
            fi
        else
            symvar "$svname" "$svvalue"
        fi
        ## Replace names[j] entry with associated symvar name for caller's use:
        names[$j]="$svname"
    done
    return
}

readVarListFile() {
    local listfile="$1"
    local SAVE="$2"
    local line
    local BLANK='^ *$'
    local BLOCKSTART='^\s*var *\('
    local BLOCKEND='^\s*\)'
    local OPENCURLYBRACKET='^ *var .*{$'
    local inblock=
    local -a names
    local name

    while IFS= read -r line; do 
        ## skip comments, blank lines, start and end of var(...) block:
        [[ $line == //* ]] && continue
        [[ $line =~ $BLANK ]] && continue
        [[ $line =~ $BLOCKSTART ]] && inblock=1 && continue
        [[ $line =~ $BLOCKEND ]] && inblock= && continue
        [[ $line =~ $OPENCURLYBRACKET ]] && {
            warn "${0#*lib/} $listfile: unable to handle 'var ... {' declarations"
            return 1
        }
        names=()
        if [[ -n $inblock ]]; then
            parse_declaration "var $line"
        else 
            parse_declaration "$line"
        fi

        [[ -n $SAVE ]] || continue
        for name in "${names[@]}"; do
            printf "%s %s\n" "$name" "$listfile" >> %VARS
        done
    done < "$listfile"
}

main() {
    local FORCE
    [[ $1 == -f ]] && FORCE=1 && shift
    local -a files=("$@")
    local file

    (( $# > 0 )) && {
        ## Process each argument @var: file, if given.
        ## Don't write to %VARS map.
        for file in "${files[@]}"; do
            readVarListFile "$file" ""
        done
        return
    }

    ## called with no arguments, process each @var: file in @ORDER

    ## delete map file which contains varnames and associated @file name:
    [[ -e %VARS ]] && rm %VARS

    ## @ORDER list file defines the element files for the target program
    while IFS= read -r file; do
        [[ $file == @var:* ]] || continue
        readVarListFile "${file%% *}" "save to map"
    done < @ORDER
}

main "$@"

